namespace k8s {
  entity UnauthenticatedUser = {};

  entity User = {
    "extra": meta::StringToStringSetMap,
    "groups": Set<__cedar::String>,
    "uid"?: __cedar::String,
    "username": __cedar::String
  };

  entity ServiceAccount = {
    "extra": meta::StringToStringSetMap,
    "groups": Set<__cedar::String>,
    "serviceAccountNamespace": __cedar::String,
    "serviceAccountName": __cedar::String,
    // TODO: Maybe add this as a convenience function, unless it complicates analysis too much
    // Most likely, we could keep this field as syntactic sugar, and actually translate it to the
    // equivalent of hasTag / getTag expressions when analyzing and interpreting the policy.
    // "nodeName"?: __cedar::String,
    "uid"?: __cedar::String,
    "username": __cedar::String
  };

  entity Node = {
    "extra": meta::StringToStringSetMap,
    "groups": Set<__cedar::String>,
    "nodeName": __cedar::String,
    "uid"?: __cedar::String,
    "username": __cedar::String
  };

  entity Resource = {
    "apiGroup": __cedar::String,
    // "apiVersion": __cedar::String,
    "name": __cedar::String,
    // TODO: If Kubernetes had a distinction between "unset" and "any" namespace, this would be an optional field,
    // that:
    // - when the SAR says "unset", would be unset (i.e, "resource has namespace" would be false), and
    // - when the SAR says "any", would be "any" (i.e, "resource has namespace" would be true), and
    // - when the SAR says "exact", would be the exact namespace name (i.e, "resource has namespace" would be true).
    // As we do not have this distinction, we cannot provide a way for checking if the namespace is "set" or "unset",
    // and thus this is a required field.
    "namespace": __cedar::String,
    "resourceCombined": __cedar::String
  };

  action "create" in ["*"] appliesTo {
    principal: [k8s::User, k8s::ServiceAccount, k8s::Node, k8s::UnauthenticatedUser],
    resource: [k8s::Resource, core::pods, core::pods_status, core::nodes, core::secrets],
    context: {}
  };

  action "get" in ["*"] appliesTo {
    principal: [k8s::User, k8s::ServiceAccount, k8s::Node, k8s::UnauthenticatedUser],
    resource: [k8s::Resource, core::pods, core::pods_status, core::nodes, core::secrets],
    context: {}
  };

  action "list" in ["*"] appliesTo {
    principal: [k8s::User, k8s::ServiceAccount, k8s::Node, k8s::UnauthenticatedUser],
    resource: [k8s::Resource, core::pods, core::pods_status, core::nodes, core::secrets],
    context: {}
  };

  action "watch" in ["*"] appliesTo {
    principal: [k8s::User, k8s::ServiceAccount, k8s::Node, k8s::UnauthenticatedUser],
    resource: [k8s::Resource, core::pods, core::pods_status, core::nodes, core::secrets],
    context: {}
  };

  action "impersonate" in ["*"] appliesTo {
    principal: [k8s::User, k8s::ServiceAccount, k8s::Node], // Should unauthenticated users & nodes ever be allowed to impersonate?
    resource: [k8s::Resource,io::k8s::authentication::users, io::k8s::authentication::serviceaccounts, io::k8s::authentication::groups, io::k8s::authentication::uids, io::k8s::authentication::userextras],
    context: {}
  };

  action "constrainedimpersonate" in ["*"] appliesTo {
    principal: [k8s::User, k8s::ServiceAccount, k8s::Node], // Should unauthenticated users & nodes ever be allowed to impersonate?
    resource: [k8s::Resource,io::k8s::authentication::users, io::k8s::authentication::nodes, io::k8s::authentication::serviceaccounts, io::k8s::authentication::groups, io::k8s::authentication::uids, io::k8s::authentication::userextras],
    context: {
      "impersonatedPrincipal": {
        // Other UserInfo fields than username. Predicates on these are returned in the condition.
        "username": __cedar::String,
        // TODO: Rewrite the schema such that the type for groups is UnknownStringSet,
        // and the type for username and uid is UnknownString, such that they can be left unknown.
        "groups"?: Set<__cedar::String>,
        "uid"?: __cedar::String,
        "extra"?: meta::StringToStringMap,
      },
      "impersonatedAction": __cedar::String,
      "impersonatedResource": k8s::Resource
    }
  };

  action "*" appliesTo {
    principal: [k8s::User, k8s::ServiceAccount, k8s::Node, k8s::UnauthenticatedUser],
    resource: [k8s::Resource, core::pods, core::pods_status, core::nodes, core::secrets, io::k8s::authentication::users, io::k8s::authentication::nodes, io::k8s::authentication::serviceaccounts, io::k8s::authentication::groups, io::k8s::authentication::uids, io::k8s::authentication::userextras],
    context: {}
  };
}

namespace k8s::nonresource {

  entity NonResourceURL = {
    "path": __cedar::String
  };

  action "*" appliesTo {
    principal: [k8s::User, k8s::ServiceAccount, k8s::Node, k8s::UnauthenticatedUser],
    resource: [k8s::nonresource::NonResourceURL],
    context: {}
  };

  action "get" in ["*"] appliesTo {
    principal: [k8s::User, k8s::ServiceAccount, k8s::Node, k8s::UnauthenticatedUser],
    resource: [k8s::nonresource::NonResourceURL],
    context: {}
  };
}

@apiGroup("")
namespace core {

  @kind("Node")
  entity nodes = {
    "apiGroup": __cedar::String,          // always ""
    "resourceCombined": __cedar::String,  // always "nodes"
    "name": __cedar::String,
    "request"?: core::VersionedNode,
    "stored"?: core::VersionedNode
  };

  type VersionedNode = {
    "apiVersion": __cedar::String,        // always "v1"
    "kind": __cedar::String,              // always "Node"
    "metadata"?: meta::V1ObjectMeta,
    // TODO
  };

  @kind("Pod")
  entity pods = {
    "apiGroup": __cedar::String,          // always ""
    "resourceCombined": __cedar::String,  // always "pods"
    "name": __cedar::String,
    "namespace": __cedar::String,
    "namespaceMetadata"?: meta::V1ObjectMeta,
    // TODO: Report the bug upstream to the VS Code Cedar plugin that autocompletion breaks when
    // the entity type here is not fully-qualified.
    "request"?: core::VersionedPod,
    "stored"?: core::VersionedPod
  };
  type VersionedPod = {
    "apiVersion": __cedar::String,        // always "v1"
    "kind": __cedar::String,              // always "Pod"
    "metadata"?: meta::V1ObjectMeta,
    "v1"?: core::V1Pod
  };
  entity V1Pod = {
    "spec"?: core::V1PodSpec,
    "status"?: core::V1PodStatus
  };
  type V1PodSpec = {
    // lots of fields
    nodeName: String,
  };
  type V1PodStatus = {
    // lots of fields
  };

  @kind("Secret")
  entity secrets = {
    "apiGroup": __cedar::String,          // always ""
    "resourceCombined": __cedar::String,  // always "secrets"
    "name": __cedar::String,
    "namespace": __cedar::String,
    "namespaceMetadata"?: meta::V1ObjectMeta,
    "request"?: core::VersionedSecret,
    "stored"?: core::VersionedSecret
  };
  type VersionedSecret = {
    "apiVersion": __cedar::String,        // always "v1"
    "kind": __cedar::String,              // always "Pod"
    "metadata"?: meta::V1ObjectMeta,
    "v1"?: core::V1Secret
  };
  entity V1Secret = {
    "type": __cedar::String,
    "data"?: meta::StringToStringMap,
    "stringData"?: meta::StringToStringMap,
    "immutable": __cedar::Bool,
  };

  @kind("Pod")
  entity pods_status = {
    "apiGroup": __cedar::String,          // always ""
    "resourceCombined": __cedar::String,  // always "pods/status"
    "name": __cedar::String,
    "namespace": __cedar::String,
    "namespaceMetadata"?: meta::V1ObjectMeta,
    "request"?: core::VersionedPodStatus,
    "stored"?: core::VersionedPodStatus
  };
  type VersionedPodStatus = {
    "apiVersion": __cedar::String,        // always "v1"
    "kind": __cedar::String,              // always "Pod"
    "metadata"?: meta::V1ObjectMeta,
    "v1"?: core::V1Pod
  };
}

@apiGroup("authentication.k8s.io")
namespace io::k8s::authentication {
  entity users = {
    "apiGroup": __cedar::String,          // always "authentication.k8s.io"
    "resourceCombined": __cedar::String,  // always "users"
    "name": __cedar::String,              // full username
  };
  entity nodes = {
    "apiGroup": __cedar::String,          // always "authentication.k8s.io"
    "resourceCombined": __cedar::String,  // always "nodes"
    "name": __cedar::String,              // node name (system:node: prefix stripped)
  };
  entity serviceaccounts = {
    "apiGroup": __cedar::String,          // always "authentication.k8s.io"
    "resourceCombined": __cedar::String,  // always "serviceaccounts"
    "name": __cedar::String,              // serviceaccount name (system:serviceaccount: prefix stripped)
    "namespace": __cedar::String,         // serviceaccount namespace
  };

  entity groups = {
    "apiGroup": __cedar::String,          // always "authentication.k8s.io"
    "resourceCombined": __cedar::String,  // always "groups"
    "name": __cedar::String,              // group name
  };
  entity uids = {
    "apiGroup": __cedar::String,          // always "authentication.k8s.io"
    "resourceCombined": __cedar::String,  // always "uids"
    "name": __cedar::String,              // uid
  };
  entity userextras = {
    "apiGroup": __cedar::String,          // always "authentication.k8s.io"
    "resourceCombined": __cedar::String,  // always "userextras/<extra key>"
    "name": __cedar::String,              // extra value
  };
}

namespace meta {

  entity UnknownString = {
    "value": __cedar::String,
  };
  entity UnknownStringSet = {
    "value": Set<__cedar::String>
  };

  entity StringToStringMap = {
    "keys": Set<__cedar::String>
  } tags __cedar::String;

  entity StringToStringSetMap = {
    "keys": Set<__cedar::String>
  } tags Set<__cedar::String>;

  entity V1ObjectMeta = {
    "annotations"?: meta::StringToStringMap,
    "deleted": __cedar::Bool,
    "finalizers"?: Set<__cedar::String>,
    "labels"?: meta::StringToStringMap,
    "uid"?: __cedar::String
  };
}