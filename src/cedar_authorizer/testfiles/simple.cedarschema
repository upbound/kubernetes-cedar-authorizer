namespace k8s {
  entity UnauthenticatedUser = {};

  entity User = {
    "extra": meta::StringToStringSetMap,
    "groups": Set<__cedar::String>,
    "uid"?: __cedar::String,
    "username": __cedar::String
  };

  entity ServiceAccount = {
    "extra": meta::StringToStringSetMap,
    "groups": Set<__cedar::String>,
    "serviceAccountNamespace": __cedar::String,
    "serviceAccountName": __cedar::String,
    "uid"?: __cedar::String,
    "username": __cedar::String
  };

  entity Node = {
    "extra": meta::StringToStringSetMap,
    "groups": Set<__cedar::String>,
    "nodeName": __cedar::String,
    "uid"?: __cedar::String,
    "username": __cedar::String
  };

  entity Resource = {
    "apiGroup": __cedar::String,
    // "apiVersion": __cedar::String,
    "name": __cedar::String,
    // TODO: If Kubernetes had a distinction between "unset" and "any" namespace, this would be an optional field,
    // that:
    // - when the SAR says "unset", would be unset (i.e, "resource has namespace" would be false), and
    // - when the SAR says "any", would be "any" (i.e, "resource has namespace" would be true), and
    // - when the SAR says "exact", would be the exact namespace name (i.e, "resource has namespace" would be true).
    // As we do not have this distinction, we cannot provide a way for checking if the namespace is "set" or "unset",
    // and thus this is a required field.
    "namespace": __cedar::String,
    "resourceCombined": __cedar::String
  };

  action "create" in ["*"] appliesTo {
    principal: [k8s::User, k8s::ServiceAccount, k8s::Node, k8s::UnauthenticatedUser],
    resource: [k8s::Resource, core::pods, core::pods_status, core::nodes, core::secrets],
    context: {}
  };

  action "get" in ["*"] appliesTo {
    principal: [k8s::User, k8s::ServiceAccount, k8s::Node, k8s::UnauthenticatedUser],
    resource: [k8s::Resource, core::pods, core::pods_status, core::nodes, core::secrets],
    context: {}
  };

  action "list" in ["*"] appliesTo {
    principal: [k8s::User, k8s::ServiceAccount, k8s::Node, k8s::UnauthenticatedUser],
    resource: [k8s::Resource, core::pods, core::pods_status, core::nodes, core::secrets],
    context: {}
  };

  action "watch" in ["*"] appliesTo {
    principal: [k8s::User, k8s::ServiceAccount, k8s::Node, k8s::UnauthenticatedUser],
    resource: [k8s::Resource, core::pods, core::pods_status, core::nodes, core::secrets],
    context: {}
  };

  action "*" appliesTo {
    principal: [k8s::User, k8s::ServiceAccount, k8s::Node, k8s::UnauthenticatedUser],
    resource: [k8s::Resource, core::pods, core::pods_status, core::nodes, core::secrets],
    context: {}
  };
}

namespace k8s::nonresource {

  entity NonResourceURL = {
    "path": __cedar::String
  };

  action "*" appliesTo {
    principal: [k8s::User, k8s::ServiceAccount, k8s::Node, k8s::UnauthenticatedUser],
    resource: [k8s::nonresource::NonResourceURL],
    context: {}
  };

  action "get" in ["*"] appliesTo {
    principal: [k8s::User, k8s::ServiceAccount, k8s::Node, k8s::UnauthenticatedUser],
    resource: [k8s::nonresource::NonResourceURL],
    context: {}
  };
}

@apiGroup("")
namespace core {

  @kind("Node")
  entity nodes = {
    "apiGroup": __cedar::String,          // always ""
    "resourceCombined": __cedar::String,  // always "nodes"
    "name": __cedar::String,
    "request"?: core::VersionedNode,
    "stored"?: core::VersionedNode
  };

  type VersionedNode = {
    "apiVersion": __cedar::String,        // always "v1"
    "kind": __cedar::String,              // always "Node"
    "metadata"?: meta::V1ObjectMeta,
    // TODO
  };

  @kind("Pod")
  entity pods = {
    "apiGroup": __cedar::String,          // always ""
    "resourceCombined": __cedar::String,  // always "pods"
    "name": __cedar::String,
    "namespace": __cedar::String,
    "namespaceMetadata"?: meta::V1ObjectMeta,
    "request"?: core::VersionedPod,
    "stored"?: core::VersionedPod
  };
  type VersionedPod = {
    "apiVersion": __cedar::String,        // always "v1"
    "kind": __cedar::String,              // always "Pod"
    "metadata"?: meta::V1ObjectMeta,
    "v1"?: core::V1Pod
  };
  entity V1Pod = {
    "spec"?: core::V1PodSpec,
    "status"?: core::V1PodStatus
  };
  type V1PodSpec = {
    // lots of fields
    nodeName: String,
  };
  type V1PodStatus = {
    // lots of fields
  };

  @kind("Secret")
  entity secrets = {
    "apiGroup": __cedar::String,          // always ""
    "resourceCombined": __cedar::String,  // always "secrets"
    "name": __cedar::String,
    "namespace": __cedar::String,
    "namespaceMetadata"?: meta::V1ObjectMeta,
    "request"?: core::VersionedSecret,
    "stored"?: core::VersionedSecret
  };
  type VersionedSecret = {
    "apiVersion": __cedar::String,        // always "v1"
    "kind": __cedar::String,              // always "Pod"
    "metadata"?: meta::V1ObjectMeta,
    "v1"?: core::V1Secret
  };
  entity V1Secret = {
    "type": __cedar::String,
    "data"?: meta::StringToStringMap,
    "stringData"?: meta::StringToStringMap,
    "immutable": __cedar::Bool,
  };

  @kind("Pod")
  entity pods_status = {
    "apiGroup": __cedar::String,          // always ""
    "resourceCombined": __cedar::String,  // always "pods/status"
    "name": __cedar::String,
    "namespace": __cedar::String,
    "namespaceMetadata"?: meta::V1ObjectMeta,
    "request"?: core::VersionedPodStatus,
    "stored"?: core::VersionedPodStatus
  };
  type VersionedPodStatus = {
    "apiVersion": __cedar::String,        // always "v1"
    "kind": __cedar::String,              // always "Pod"
    "metadata"?: meta::V1ObjectMeta,
    "v1"?: core::V1Pod
  };
}

namespace meta {

  entity UnknownString = {
    "value": __cedar::String,
  };

  entity StringToStringMap = {
    "keys": Set<__cedar::String>
  } tags __cedar::String;

  entity StringToStringSetMap = {
    "keys": Set<__cedar::String>
  } tags Set<__cedar::String>;

  entity V1ObjectMeta = {
    "annotations"?: meta::StringToStringMap,
    "deleted": __cedar::Bool,
    "finalizers"?: Set<__cedar::String>,
    "labels"?: meta::StringToStringMap,
    "uid"?: __cedar::String
  };
}